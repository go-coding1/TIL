# 1장 인프라 아키텍처를 살펴보자

* 집약형 아키텍처

  시스템 아키텍처라는 관점에서는 하나의 컴퓨터로 모든 처리를 하기 때문에 '집약형'이라고 할 수 있다. 집약형의 최대 장점은 구성이 간단하다는 것이다.

  집약형 아키텍처에서는 해당 기업의 주요 업무를 모두 한 대로 처리하기 때문에 장비 고장 등으로 업무가 멈추기 않도록 여러 고민을 하고 있다. 그래서 주요 부품은 다중화 한다.

  * 장점 

    한 대의 대형 컴퓨터만 있으면 되므로 구성이 간단하다

    대형 컴퓨터의 리소스 관리나 이중화에 의해 안정성이 높고 고성능이다.

  * 단점

    대형 컴퓨터의 도입 비용과 유지 비용이 비싸다

    확장성에 한계가 있다.

* 분할형 아키텍처

  여러 대의 컴퓨터를 조합해서 하나의 시스템을 구축한다(컴퓨터 간에 데이터를 주고 받는다)

  분할형 아키텍처는 표준 OS나 개발 언어를 이용하기 때문에 '오픈 시스템'이라고도 부른다. 또는 '분산 시스템'이라 부르는 경우도 있다.

  * 장점

    낮은 비용을 시스템을 구축할 수 있다.

    서버 대수를 늘릴 수 있어서 확장성이 높다.

  * 단점

    대수가 늘어나면 관리 구조가 복잡해진다.

    한 대가 망가지면 영향 범위를 최소화하기 위한 구조를 검토해야 한다.

* 물리 서버와 논리 서버 차이

  ![IMG_5297](https://user-images.githubusercontent.com/54675591/138576728-2920f30a-a3da-4e97-acc5-13a0efe5e2ca.JPG)

  인터넷에 접속했을 때 사용자 입력 및 HTML 생성을 담당하는 것은 서버세어 동작하는 소프트웨어인 '웹 서버'다. 대량의 데이터를 저장해서 요청에 따라 데이터를 제공하는 것은 데이터베이스 기능을 제공하는 'DB서버'다.

* 수직 분할형 아키텍처

  서버별로 다른 역할을 담당하는 것.

* 클라이언트 - 서버형 아키텍처

  사용자가 클라이언트(단말기 ,PC, 스마트폰 등)으로 요청을 하면 클라이언트는 서버에게 접속해 이용하는 형태이다.

  클라이언트-서버형의 특징은 클라이언트 측에 전용 소프트웨어를 설치해야 한다는 것이다. 이에 따라 기업에서 정기적이 업데이트가 생기면 클라이언트 측 소프트웨어도 업데이트해야 한다. 이 업데이트를 하지 않으면 모든 기능을 사용할 수 없고, 이용자가 반드시 업데이트한다는 보장도 없어서 시스템 위험 요소가 될 수 있다. 또한, 서버에 처리가 집중되면 확장성에 한계가 발생할 가능성이 있다. 이러한 단점을 개선하려고 한 것이 3계층형이다.

  * 장점

    클라이언트 측에서 많은 처리를 실행할 수 잇어서 소수의 서버로 다수의 클라이언트를 처리할 수 있다.

  * 단점

    클라이언트 측의 소프트웨어 정기 업데이트가 필요하다.

    서버 확장성에 한계가 발생할 수 있다.

* 3계층형 아키텍처

  '프레젠테이션 계층' '애플리케이션 계층' '데이터 계층'의 3층 구조로 분할돼 있어서 3계층형이라고 부른다.

  * 프레젠테이션 계층

    사용자 입력을 받는다

    웹 브라우저 화면을 표시한다

  * 애플리케이션 계층

    사용자 요청(Request)에 따라 업무 처리를 한다.

  * 데이터 계층

    애플리케이션 계층의 요청에 따라 업무 처리를 한다.

  3계층 시스템에서는 사용자가 웹 브라우저를 통해 시스템에 접속한다. 예를 들어, 인터넷 검색 시스템에서는 사용자가 웹 브라우저에 입력하는 화면은 프레젠테이션 계층의 웹 서버에 먼저 전달된다. 웹 서버는 그 요청을 뒤에 있는 애플리케이션 계층의 애플리케이션 서버(AP서버)에 전달한다. AP서버는 검색 키워드를 바탕으로 무엇을 검색해야 할지 판단해서 뒤에 있는 데이터 계층의 데이터베이스(DB서버)에 데이터를 요청한다.

  * 장점

    서버 부하 집중 개선

    클라이언트 단말의 정기 업데이트가 불필요

    '처리 반환'에 의한 서버 부하 저감

  * 단점

    구조가 클라이언트-서버 구성보다 복잡하다.

* 수평 분할형 아키텍처

  수평 분할형 아키텍처는 용도가 같은 서버를 늘려나가는 방식이다. 서버 대수가 늘어나면 한 대가 시스템에 주는 영향력이 낮아져서 안정성이 향상된다.

  * 장점

    수평으로 서버를 늘리기 때문에 확장성이 향상된다.

    분할한 시스템이 독립적으로 운영되므로 서로 영향을 주지 않는다

  * 단점

    데이터를 일원화해서 볼 수 없다.

    애플리케이션 업데이트는 양쪽에 동시에 해 주어야 한다

    처리량이 균등하게 분할돼 있지 않으면 서버별 처리량에 치우침이 생긴다

* 공유형 아키텍처

  공유형에서는 단순 분할형과 달리 일부 계층에서 상호 접속이 이루어 진다. 보통 DB를 상호 접속한다. 데이터 도익 처리를 위한다. 이 경우 서로 다른 시스템 측의 정보를 읽어올 수 있다. 데이터 계층은 데이터 저장고의 역할도 하기 때문에 보안이 필요한 데이터가 저장되는 경우도 많다.

  * 장점

    수평으로 서버를 늘리기 때문에 확장성이 향상된다.

    분할한 시스템이 서로 다른 시스템의 데이터를 참조할 수 있다.

  * 단점

    분할한 시스템 간 독립성이 낮아진다.

    공유한 계층의 확장성이 낮아진다.

* 스탠바이형 아키텍처

  물리 서버를 최소 두 대를 준비하여 한 대가 고장 나면 가동 중인 소프트웨어를 다른 한 대로 옮겨서 운영하는 방식이다. 이때 소프트웨어 재시작을 자동으로 하는 구조를 페일오버(Failover)라고 한다.

# 2장 서버를 열어보자

* 대역

  원래는 주파수 대역을 가리키지만, IT인프라에서는 의미가 조금 다르다. 대역은 데이터 전송 능력을 의미한다. 대역은 '한번에 데이터를 보낼 수 있는 데이터의 폭' x '1초에 전송할 수 잇는 횟수'로 결정된다.

# 3장 3계층형 시스템을 살펴보자

![IMG_5299](https://user-images.githubusercontent.com/54675591/138578512-0d19e0ce-8dfc-4439-bff9-9ed6bec6d487.JPG)

* 프로세스와 스레드

  프로세스 및 스레드는 프로그램 실행 파일 자체가 아니라 OS상에서 실행돼서 어늦 ㅓㅇ도 독립성을 가지고 동작하는 것이다. 대부분의 책이 '사람 모양'으로 표현하고 있듯이. 프로세스나 스레드가 시작되는 것은 마치 사람이 숨을 쉬기 시작하면서 활동하는 것과 같은 의미다. 

* 웹 서버

  httpd프로세스라고 쓰여 있는 막대 인간이 프로세스다. 그 주변을 감싸고 있는 하얀 공간이 있는데, 이것이 프로세스의 메모리 공간을 나타낸다.

* AP 서버

  스레드라고 쓰여 있는 막대 인간이 스레드다. 웹 서버와 달리 AP서버 상의 막대 인간은 하나의 메모리 공간을 공유하고 있다. 이것이 프로세스와 스레드의  큰 차이점이다. **프로세스는 전용 메모리 공간을 이용해서 동작한다. 스레드는 다른 스레드와 메모리 공간을 공유하고 있는 운명 공동체이다.**

  프로세스와 스레드 중에 어떤 것을 이용할지는 애플리케이션 개발자가 정한다. 이때 각자의 특성을 이해하고 설계와 프로그래밍할 필요가 있다. 예를 들어, 프로세스는 독자 메모리 공간을 가지기 때문에 생성 시 CPU 부하가 스레드와 비교해 높아진다. 때문에 멀티 프로세스 애플리케이션에서는 프로세스 생성 부담을 낮추기 위해 미리 프로세스를 시작시켜 둔다. 

* OS 커널

  OS 처리는 원칙적으로 커널을 통해 이루어진다. 커널의 역할에는 여러 가지가 있지만, 5가지로 정리할수 있다.

  1. 시스템 콜 인터페이스

     프로세스/스레드에서 커널로 연결되는 인터페이스다. **애플리케이션이 OS를 통해서 어떤 처리를 하고 싶으면 시스템 콜이라고 하는 명령을 이용해서 커널에 명령을 내린다.** 예를 들어, 디스크상의 데이터를 읽고 싶거나 네트워크 통신을 하고 싶을 때, 또는 새로운 프로세스를 생성하고 싶은 경우에 해당 시스템 콜을 호출하면 기능을 이용할 수 있다. (디스크 I/O와 네트워크 I/O과 본질적인 차이는 없다. 둘다 프로세스 관점에서는 동일한 시스템 콜이다.)

  2. 프로세스 관리

     OS상에서는 수십, 수백, 수천 갱의 프로세스를 가동할 수 있다. 이에 비해 물리 서버의 CPU 코어 수는 많아야 수십 개 정도밖에 안 된다. 언제, 어떤 프로세스가 어느 정도 CPU 코어를 이용할 수 있는지, 처리 우선순위를 어떻게 결정할 것인지 등을 관리하는 것이 이 기능의 역할이다.

  3. 메모리 관리

     메모리 영역을 관리한다. 메모리 관리에서는 물리 메모리 공간의 최대치를 고려한다. 프로세스가 이용하는 독립 메모리 공간을 확보하거나 상호 간의 참조 영역을 지키기 위해 독립성을 관리하는 등의 메모리 관리 역할을 한다. 

  4. 네트워크 스택

     이 후 설명 

  5. 파일 시스템 관리

     파일 시스템용 인터페이스를 제공한다. 파일 시스템은 OS기능의 하나로서 물리 디스크에 제공된 데이터를 관리하는 기능이다. 주요 관리 기능으로는 디렉터리 구조 제공, 액세스 관리, 고속화, 안정성 향상 등이 있다.

  6. 장치 드라이버

     물리 장치용 인터페이스를 제공한다.

* #### 웹 데이터 흐름

  그림 이하 설명

  ![IMG_5300](https://user-images.githubusercontent.com/54675591/138582158-614bb178-7845-453e-af68-88f883713e00.JPG)

  * 클라이언트 PC부터 웹 서버까지 연결

    큰 흐름은 아래와 같다

    1. 웹 브라우저가 요청을 발행
    2. 이름 해석
       1. 웹 르라우저는 naver.com의 IP주소를 모른다.
       2. OS의 호스트명, IP주소 변환 테이블을 참조해서 존재하지 않는 경우, 외부의 DNS서버에 요청을 던진다.
       3. 전 세계에 있는 DNS서버는 Root DNS를 기준으로 트리구조로 돼있다. 개별 DNS서버는 정기적으로 부모 DNS서버에서 데이터를 받아서 최신 IP주소 목록을 유지한다.
       4. IP주소 검색 결과가 반환된다.
    3. 웹 서버가 요청을 접수한다
    4. 웹 서버가 정적 콘텐츠인지 동적 콘텐츠인지 판단한다
    5. 필요한 경로로 데이터에 액세스한다

    주소 창에 http://naver.com을 입력하고 엔터키를 누른다. 하지만 웹 브라우저는 이 서버가 어디에 있는지 모르기 때문에 조사를 시작한다. 이 구조를 이름 해석(Name Resolution)이라고 한다. 어찌저찌 웹 서버에 도착했다. 웹 서버의 역할은 HTTP요청에 대해 적절한 파일이나 콘텐츠를 반환하는 것이다. 현재 HTTP는 이미지나 동영상 데이터 전송에도 이용되지만, 어디까지나 기본은 텍스트 데이터다.

    요청에 대한 대답 내용은 HTML 파일이라는 텍스트 데이터나 이미지, 동영상 등의 바이너리 데이터로 구성된다.

    동적 컨텐츠는 일반적으로 AP서버가 HTML 파일을 동적으로 생성한다. 웹 서버는 동적 컨텐츠에 대한 요청을 AP서버에게 던지고 결과를 기다린다.

  * 웹 서버 -> AP서버

    동적 컨텐츠에 대한 요청을 처리하는 것이 AP서버다. 

    ![IMG_5301](https://user-images.githubusercontent.com/54675591/138582473-6943c3f5-f094-4175-80a2-6718f56e23e4.JPG)

    1. 웹 서버로부터 요청이 도착한다
    2. 스레드가 요청을 받으면 자신이 계산할 수 있는지, 아니면 DB접속이 필요한지를 판단한다
    3. DB접속이 필요하면 연결 풀에 액세스한다
    4. DB서버에 요청을 던진다.

    자바를 이용한 AP 서버에서는 JVM이라 불리는 가상 머신이 동작하고 있다. 이 JVM도 하나의 거대한 프로세스다. 가상 머신은 그 명칭이 보여 주듯이, 하나의 OS로서 다양한 기능을 가지고 있다. 

  * AP 서버 ->  DB서버

    1. AP서버로부터 요청이 도착한다
    2. 프로세스가 요청을 접수하고 캐시가 존재하는지 확인한다
    3. 캐시에 없으면 디스크에 액세스한다
    4. 디스크가 데이터를 반환한다
    5. 데이터를 캐시 형태로 저장한다
    6. 결과를 AP 서버에 반환한다

  * AP서버 ->  웹서버

    1. DB서버로부터 데이터가 도착한다
    2. 스레드가 데이터를 가지고 계산 등을 한 후에 파일 데이터를 생성한다
    3. 결과를 웹 서버로 반환한다

  * 웹 서버 -> 클라이언트 PC

    1. AP 서버로부터 데이터가 도착한다
    2. 프로세스는 받은 데이터를 그대로 반환한다
    3. 결과가 웹 브라우저로 반환되고 화면에 표시된다

  * 정리

    3계층 시스템에서는 사용자 요청이 시발점이 돼서 해당 요청이 다양한 서버로 전달된다. 특징으로는 자신이 할 수 없는 처리는 다음 서버에게 그 역할을 떠넘긴다는 것이다. **요청 기반 아키텍처이기 때문에 기본적으로 각 서버는 '문을 열고 기다리고 있는' 상태다. 이것이 IT인프라에서 성능 문제가 발생하는 이유 중 하나다** 

* ### 가상화

  가상화란, 한 마디로 정의하면 **'컴퓨터 시스템에서 물리 리소스를 추상화하는 것'**이다.

  OS도 가상화 기술 중 하나라고 볼 수 있다. OS의 커널에 의해 하드웨어가 추상화되면서, 컴퓨터에 연결된 기억 장치나 네트워크를 통한 데이터 교환이 하드웨어를 의식하지 않고 이루어지고 있다.

* 가상 머신

  가상 머신 방식에는 호스트 OS형과 하이퍼바이저형이 있다. 호스트 OS형은 윈도우즈나 리눅스 등의 호스트OS상에 가상화 소프트웨어를 설치해서 이용하는 것으로, VMware Server등이 있다. 소프트웨어를 에뮬레이터하는 것으로 성능면에서 제한이 있다. 그래서 등장한 것이 하이퍼바이저형으로 VMware vSphere, Hyper-V, Xen, KVM 등이 이에 속한다. 하이퍼바이저형은 하드웨어상에서 직접 가상화 소프트웨어를 실행하고 그 위에 가상 머신을 동작시키는 기술이다. 호스트 OS를 거치지 않으므로 호스트형보다 성능이 우수해서 서버 가상화의 대표 기술로 자리 잡았다.

* 컨테이너의 역사

  도커(Docker)의 등장 이후 컨테이너(Container)가 급속도로 유행하기 시작했다. **컨테이너는 '리소스가 격리된 프로세스'다.** 하나의 OS상에서 여러 개를 동시에 가동할 수 있으며, 각각 독립된 루트 파일 시스템, CPU/메로리, 프로세스 공간 등을 사용할 수 있다는 점이 하드웨어 가상화인 가상 머신과의 차이다.

* 도커의 등장

  2013년 파일 시스템과 프로세스를 분리하는 기능이 추가됐다. 이를 통해 파일 시스템 이미지의 패키징과 버저닝이 가능해졌고 컨테이너 이미지를 공유할 수 있는 도커가 등장함으로써 컨테이너 기술이 주목을 받기 시작했다.

  ![IMG_5303](https://user-images.githubusercontent.com/54675591/138583241-9a538b70-c788-4737-86b4-b8027e6b283c.jpg)

  클라우드에서 새롭게 배포를 하면 애플ㄹ리케이션 관련 프레임워크나 라이브러리 등의 버전이 일치하지 않아서 로컬에서 실행된 프로그램이 클라우드에서는 실행되지 않는 문제가 빈번하게 발생했다. 따라서 원래 클라우드 내부 구조로 개발했던, 애플리케이션 실행 환경을 자동 구축해주는 '도커 이미지'라는 기술을 클라우드 이외의 환경에서도 사용할 수 있게 오픈 소스로 공개했다. 또한, 도커 허브(Docker Hub)라는 도커 이미지를 공유할 수 있는 레지스트리가 생겨나면서 폭발적인 인기를 얻기 시작했다.

  * 컨테이너는 호스트 OS와 OS커널을 공유하므로 컨테이너 실행이나 정지 속도가 빠르다.
  * 호스트 OS의 커널을 공유하므로 VM만 사용하는 경우와 비교해 한 대의 호스트 머신상에서 훨씬 많은 컨테이너를 실행할 수 있다. 이를 통해 리소르를 한 곳에서 쉽게 관리할 수 있다.
  * 도커는 라이브러리나 프레임워크 등을 도커 이미지로 묶어서 공유할 수 있는 것으로, 특정 환경에서는 재현되지만 자신의 개발 환경에서는 재현되지 않는 문제가 발생하기 어렵다.  따라서 버그를 효율적으로 수정할 수 있다.

* 클라우드와 가상화 기술

  AWS, GCP, Azure 등의 클라우드 서비스에서는 가상 머신 서비스, 컨테이너 서비스, Faas 서비스나 다른 기타 서비스를 지탱하는 기술로 이용되고 있다.

# 4장 인프라를 지탱하는 기본 이론

### 직렬 병렬

CPU라는 미시적인 관점에서 시스템 전체라는 거시적인 관점으로 눈을 돌리면, 대귬 웹 서비스에서는 방대한 수의 사용자 요청을 처리해야 하므로 수많은 서버를 배치해서 병렬로 처리하고 있음을 알 수 있다. 이처럼 주변에는 병렬 처리가 넘쳐나고 있지만, 무조건 병렬화한다고 해서 성능이 향상되는 것은 아니다. 예를 들어 CPU코어나 서버를 병령화할 때는 병렬화한 하드웨어를 늘리지 않고 어떻게 효율적으로 활용할지가 중요해진다.

컴퓨터 세계에서는 CPU나 HDD 등의 하드웨어 성능은 제품에 따라 차이가 나지만, 성능이 아무리 좋은 하드웨어라도 혼자서 처리할 수 있는 양이 정해져 있다.

![IMG_5306](https://user-images.githubusercontent.com/54675591/138585124-623c7e5a-9737-4f27-a661-a3c17e8cd718.JPG)

위 그림을 보면 특정 기간 내에 하나의 CPU로 처리할 수 있는 양에는 한계가 있지만, 여러 개의 CPU를 배치하면 처리량을 늘릴 수 있다. 단, 다수의 CPU를 이용할 수 있는 처리여야 한다는 전제 조건이 있다. 분담해서 병렬화할 수 없는 처리는 CPU 코어를 아무리 늘도 효과가 없다. 이때는 CPU 클럭 주파수를 올리는 방법, 즉 직렬 처리 속도를 올리면 고속 처리가 가능하다. 정리하자면 다음과 같다

1. 직렬 처리로 속도를 올리는 데는 한계가 있다.
2. 병렬화를 통해 속도는 빨라지지 않지만, 단위 시간당 처리량을 늘릴 수 있다.
   * 병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다
   * 병렬화할 때는 일을 분담해서 처리를 한 후 다시 집약할 때 오버헤드가 걸린다. 그러므로 이 오버헤드를 감안하더라도 효과가 있을 경우에 병렬화를 한다.

* 웹 서버와 AP 서버에서의 병렬화

  웹 서버에는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 하고 있다. AP 서버에서는 JVM프로세스가 하나이지만 복수의 스레드가 병렬로 처리하고 있다. 하나의 CPU코어 밖에 없는 서버에서는 아파치 프로세스를 아무리 늘려도 동시에 실행할 수 있는 것은 1개 프로세스뿐이다. 프로세스나 스레드 수를 조정할 때는 CPU 코어 숟 함께 고려해야한다. 편의점 계산대가 하나밖에 없다면 계산대를 담당하는 사람이 여러 명이라도 소용 없는 것과 마찬가지다.

|      | 장점                                                         | 단점                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 직렬 | 구조가 간단해서 설계나 구현 난이도가 낮다                    | 복수의 리소스(컴퓨터나 프로세서 등)를 유용하게 이용할 수 없다. |
| 병렬 | 복수의 리소스(컴퓨터나 프로세서 등)를 유용하게 이용할 수 있으며, 직렬에 비해 동일 시간당 처리할 수 있는 양이 증가한다. 또한, 일부가 고장나더라도 처리를 계속할 수 있다. | 처리 분기나 합류를 위한 오버헤드가 발생한다. 배타적 제어 등을 고려해야 하고 구조가 복잡해서 설계나 구현 난이도가 높다. |

* 동기/비동기

  동기는 다른 사람에게 일을 부탁한 후 끝날 때까지 아무것도 하지 않고 기다리기 때문에 그 사이에 다른 것을 할 수 없다. 하지만 의뢰한 것이 끝났는지 여부를 확실하게 확인할 수 있다

  비동기는 끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있다. 하지만 의뢰한 일이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 한다.

* DBMS에서 사용되는 비동기 I/O

  비동기 I/O는 대량의 I/O를 효율적으로 처리해야 하는 DBMS에 적합하다고 할 수 있다. 공유 메모리에 있는 다수의 데이터를 프로세스가 HDD에 기록하는 경우, 비동기 I/O라면 하나의 I/O가 끝나기까지 기다리지 않고 다음 I/O를 발행할 수 있기 때문에 저장소 성능을 충분히 활용할 수 있다.

|        | 장점                                                         | 단점                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 동기   | 의뢰한 처리가 끝났는지 여부를 쉽게 확인할 수 있어서 구조가 간단하고 구현 난이도도 낮다 | 의뢰한 처리가 끝나기 까지 기다려야 하기 때문에 대기 시간을 활용할 수 없다 |
| 비동기 | 의뢰한 처리가 진행되고 있는 동안 시간을 효율적으로 사용해서 병렬 처리를 할 수 있다. | 의뢰한 처리가 끝났는지 확인하지 않으면 모르기 때문에 불필요한 확인 처리가 늘어난다. 구조가 복잡해서 구현 난이도가 높다. |

* 큐

  큐의 특징은 선두에서부터 순서대로 처리된다는 점이다. 여러 처리가 동시에 진행되는 경우에는 이 큐가 자주 사용되며, 다양한 계층의 여러 부분에서 이 큐가 이용되고 있다. 예를 들어, 데이터베이스의 성능 문제와 관련해서는 데이터베이스 큐, OS 런큐, I/O 요청 큐 등을 확인하면 처리 지연이 발생하고 있는지 확인할 수 있다. 

  메시지 큐 같은 거시적인 것도 있다. 메시지 큐를 사용하면 애플리케이션 간 상호 운용성을 향상시켜서 시스템 전체 안정성을 향상시킬 수 있다. 어딘가가 멈다고 해서 시스템 전체가 멈추는 것은 아니기 때문이다.

* 배타적 제어

  배타적 제어는 문자 그대로 '다른 것을 배제하는 제어'다. 여러 사람이 공유하는 물건일 경우, 누군가가 그 물건을 사용하고 있음ㄴ 다른 사람은 그것은 사용할 수 없다. 동시에 사용할 수 없다. 동시에 사용하게 되면 고장이 날 수 있다. 여러 사람이 공유하기 때문에 배타적 제어가 필요한 것이다.

  직렬 처리에서는 배타적 제어가 필요 없지만, 병렬 처리에서는 필요하다. 배타적 제어를 하는 부분은 병목 현상이 발생하기 쉽다. 병렬 처리와 배타적 제어를 머릿속에 그릴 수 있게 되면 문제 해결이나 성능 튜닝에 도움이 된다.

  * 복수의 처리가 공유 자원(CPU,메모리,디스크)에 동시에 액세스(주로 갱신)하면 불일치가 발생할 수 있기 때문에 배타적 제어로 보호해 주어야 한다.
  * 배타적 제어에서는 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치가 발생하지 않도록 한다.
  * 예를 들어, 3차선 도로가 1차선이 되는 부분과 같다. 3차선으로 나누어 운행하던 자동차가 1차선으로 집약되기 때문에 한 대의 자동차가 통과할 때는 다른 차선의 자동차가 들어오지 않도록 배타적 제어를 한다. 이런 부분에서는 병목 현상이 발생하기 쉽다.

* 상태 저장/ 상태 비저장

  상태 정보를 가지는 '상태 저장'(stateful)과 가지지 않는 '상태 비저장'(stateless)라는 의미이다.

  정보를 많이 가지고 있는 상태 저장은 세분화된 제어가 가능한 반면에 구조가 복잡하다. 한편, 상태 비저장은 고기능은 아니지만 간단하다. Ex) SSH - 상태 저장 프로토콜, HTTP - 상태 비저장 프로토콜

  * 상태 저장은 상태를 고려하기 때문에 복잡한 처리가 가능하지만, 시스템 복잡성이 커진다.
  * 상태 비저장은 상태를 고려하지 않기 때문에 간단하며, 성능이나 안정성 측면에서 우수하다.

* 프로세스의 상태 전이

  ![IMG_5331](https://user-images.githubusercontent.com/54675591/138670012-23ed9de8-5b4c-460e-a6db-95b17e704a66.JPG)

* 네트워크 통신 구조

  HTTP는 기본적으로 상태 비저장 방식이지만, 상탤ㄹ 저장해야 하는 경우가 있다.(로그인 상태) HTTP에서는 세션(Session)이라는 개념을 사용해서 그 구조를 구현하고 있다. 로그인 드으이 인증을 거치면 서버는 그 상태를 저장함과 동시에 인증 완료 세션 정보를 반환한다. 

* 가변 길이/ 고정 길이

  데이터를 넣을 때 미리 크기가 정해져 있는 경우를 고정 길이, 정해져 있지 않은 경우를 가변 길이라고 한다.

  고정 길이의 장점은 틀의 크기가 정해져 있어서 원하는 것에 쉽게 액세스 할 수 있다는 것이다. 대신에 남는 공간이 생겨서 이 공간을 효율적으로 활용하는 것이 어렵다.

  가변 길이에서는 데이터를 꽉 채워서 담을 수 있기 때문에 저장 시의 데이터 크기를 절약할 수 있다는 장점이 있다. 단, 칸막이 위치가 정해져 있지 않아서 원하는 책을 찾으려면 고정 길이에 비해 많은 시간이 걸린다.

* B 트리 인덱스

  ![IMG_5332](https://user-images.githubusercontent.com/54675591/138671694-721d05c3-0e1c-4619-84bf-f673c5881688.JPG)

  1이 루트 블록, 2가 브랜치 블록, 3이 리프 블록이다. 루트는 나무의 뿌리, 브랜치는 가지, 리프는 잎에 해당한다. 나무처럼 뿌리 -> 가지 -> 잎 순서를 거쳐서 잎에 도달하면 원하는 데이터 저장 위치가 기록돼 있는 형태다.

  `SELECT * FROM EMP_WHERE EMPNO = 7639` 라는 SQL을 발행하면 1루트 블록을 보고, 2브랜치 블록1 아래에 있다는 것을 안다. 브랜치 블록1을 보면 3리프 블록1에 있다는 것을 안다. 리브 블록1을 보면 4의 데이터 블록이 어디에 데이터가 저장돼 있는지 알 수 있다. 이와 같은 구조로 4개의 블록만 읽으면 데이터를 찾을 수 있다.

  이처럼 인덱스는 읽을 블록 수를 줄이기 위한 수단이지만, 인덱스를 사용하면 오히려 읽을 블록 수가 늘어날 수도 있다.

  B트리 인덱스가 DBMS에서 자주 사용되는 것은, 트리 구조 계층이 깊어지지 않도록 디스크 I/O를 최소한으로 제어하기 때문이다. 반대로, 메모리에 모든 데이터를 두는 인메모리 DB에서는 디스크 I/O를 신경 쓸 필요가 없기 때문에 디스크에 데이터가 저장된다는 것을 전제로 개발된 DBMS와는 다른 접근 방법이 필요하다.

# 5장 인프라를 지탱하는 응용이론

### 캐시

* cache에는 '숨기는 장소'라는 의미가 있다. 컴퓨터 세계에서는 캐시는 사용 빈도가 높은 데이터를 고속으로 액세스할 수 있는 위치에 두는 것을 의미한다.
  * 일부 데이터를 데이터 출력 위치와 가까운 지점에 일시적으로 저장한다.
  * 데이터 재사용을 전제로 한다.
* 웹 브라우저나 실시간 스트리밍에서는 캐시 또는 캐시 서버를 두어 사용하기도 하지만 대량의 데이터에 액세스하는 시스템에서는 캐시는 부적합하다.
  * 데이터가 실제 데이터와 캐시라는 이중 구조로 저장되기 때문에 리소스 소비가 늘어난다. 설계 시에는 어떤 데이터를 캐시하는 것이 효과적인지를 검토해야 한다.
  * 시스템 가동 직후 등에는 캐시에 데이터가 없기 때문에 원하는 성능이 나오지 않을 수 있다.
  * 캐시 계층이 늘어나기 때문에 시스템 성능 문제나 데이터 불일치 문제가 발생한 경우는 문제 발생을 야기한 용의자가 늘어난다.
  * 캐시의 데이터가 손실되는 경우를 대비해서 복구 순서를 설계 시에 확립해야 한다.
  * 갱신 데이터(쓰기 데이터)를 캐시할 때 캐시가 여러 개 있으면 갱신된 최신 데이터를 서로 뺏으려는 상태가 발생하지 않도록 주의해야 한다.

### 끼어들기