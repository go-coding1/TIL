# Spring Triangle[IoC,AOP,PSA]

 Java를 선택해 개발을 하다보면 거의 무조건적으로 Spring을 만나게 될 수 밖에 없다. 처음 스프링을 사용했을 때의 신기함은 잊혀지지 않았다. 내가 쓴 코드로 실제 서버가 돌아가고 심지어 대부분의 회사들이 Spring을 사용해서 실제 서비스를 진행하고 있다는 사실이 나에게 실제 개발세계에 발을 담그는 순간이 되었다.

 하지만 Spring을 공부하면 할 수록 마인드맵 가지처럼 공부해야할 내용은 많아지고 겉핥기식으로 공부하다보니 기초가 부족하다는 생각이 들었다. 오류를 봐도 읽지 못하게 순간이 왔었다. 구글에 검색해서 찾아보면 오류를 잘 읽고 스프링의 아키텍처를 잘 알고있다면 금방 고칠 수 있는 오류들이였다.~~(특히 스프링 환경설정 부분에서 많은 오류를 만들었었다. SpringBoot를 그런점에서 사랑한다 )~~.  이 글에서는 스프링의 가장 기본이 되는 부분부터 시작할 것이다.

# 그래서 Spring이 뭔데?

*스프링에 대해서 설명해보세요* 

*눼? 어 음... 웹서버를 위한 프레임워크??*

예전에는 이렇게 대답했을 것이다. 맞는 말인데 맘에 들지 않는 답변이다. 세상에 웹 서버를 위한 프레임워크는 수도없이 많다. 스프링의 가장 큰 특징은 **잘만든 객체지향언어 프레임워크** 라고 말하고 싶다. 실제로 스프링프레임워크는 JAVA의 4대특성(추상화,캡슐화,상속성,다형성), 디자인 패턴(SOLID)에 입각해서 만들었다. 스프링프레임워크는 정말 유지보수에 좋고, 개발자에게 개발하기 좋은 환경을 제공한다. 물론 Container, DispatcherServlet 등 여러가지 개념을 알고있으면 좋지만 하지만 천재적인 개발자분들이 Spring을 너무나도 잘 만들어놔서 위의 개념을 잘 모르더라도 Spring에 충분히 쉽게 다가갈 수 있다. 

# SpringTriangle(3요소)

사진

Spring개발자한테 Spring Triangle 물어봤을 때 대답 못하면 진짜 혼나야한다. 그 만큼 기본중에 기본이다. 3대 요소를 설명하기에 앞서 POJO먼저 이해해야한다. 

#### POJO(Plain Old Java Object)

POJO는 평범한 구식 자바 객체이다. 뭐가 평범하고 구식이라는 걸까? Build()패턴이라도 쓸수있게 하면 최신인걸까? 예전에 EJB 방식으로 많은 개발을 하였다. 그때는 EJB가 최고였지만 점점 시간이 지나고 여러가지 문제가 발생했다. 객체지향적인 특징과 장점을 포기해야했고, 상속과 다형성등의 특징들을 제대로 사용하지 못하는 문제가 발생했다. 왜냐면 기술적으로 너무 복잡하고 설계도 어렵게 짜여져있었다.  JAVA를 사용하면서 객체지향의 원리를 이용하지 못하는 것은 매우 슬픈일이였다. 

그래서 마틴 파울러는 EJB와 같은 잘못 설계된 과도한 기술을 피하고, 객체지향 원리에 따라 만들어진 자바 언어의 기본에 충실하게 비즈니스 로직을 구현하는 일명 POJO 방식으로 돌아서야 한다고 지적했다. POJO 방식의 개발은 EJB가 잃어버린 소중한 가치인 객체지향적인 설계와 자동화된 테스트의 편의성, 개발생산성 등을 회복시켜 줄 수 있는 길이기 때문이다.

결국 POJO는 

* 특정 규약에 종속되지 않는다.
* 특정환경에 종속되지 않는다.
* 객체지향원리에 충실해야 한다.

의 특징을 가지고있다. 스프링 프레임워크는 **POJO기반의 프레임워크**이다. 스프링은 POJO프레임워크 중 하나이다. 내가 위에서 스프링은 잘만든 객체지향언어 프레임워크라고 했던 말이 기억날것이다. 이 말이 결국 POJO프레임워크라는 말이다.

# IoC/DI

> Inversion Of Control/ Dependency Injection

그래로 해석하자면 제어의 역전/ 의존성 주입 이라는 말 입니다.

일반적인 제어와 의존성 주입은

```java
public class IoCDI{
    private Serivce service;	
    
    public IoCDI(){
        service = new Service();	//의존성을 개발자가 주입함
    }
    
    public void run(){
        service.run();
    }
}
```

위의 코드 형태가 기본이 됩니다. 개발자가 스스로 new()를 사용해서 의존성을 클래스에 의존성을 주입하게 됩니다. 제어의 역전은 new()를 개발자가 해주는것이 아니라 Spring이 해주도록 하는것입니다. 결국 개발자는 new를 사용할 일이 없습니다. 위의 코드에 IoC를 적용해보면

```java
@Component
public class IoCDI{
    @Autowired
    private Service service;
    
    public void run(){
        service.run();
    }
}
```

개발자는 코드어디에서도 Service를 new()를 통해서 생성하지 않았습니다. 스프링이 Service 빈을 다 생성해주었기 때문입니다. 이미 생성되어 있는 Bean을 가져와서 사용하게 됩니다. 제어의 역전을 하는 방법은 무수히 많습니다. 근데 굳이 제어의 역전을 하는 이유는 무엇일까요?

스프링은 스프링내부에 스프링컨테이너를 가지고 그 안속에 빈을 생성해 놓아 빈을 관리하고있습니다. 개발자 스스로가 new를 사용해 빈을 생성하게 되면 메모리 관리의 문제도 생기게 되고, 쓸데없는 로직이 추가적으로 생기게 됩니다. 그리고 스프링이 모든 빈을 관리해야 하는데 개발자가 빈을 생성하게 되면 나중에 빈을 사용할때 어떠한 빈을 가져다 사용할지 알기도 힘들게 됩니다. 개발자는 개발 로직에 집중할 수 있게끔, 제어의 역전이 일어나게 됩니다.

# AOP

> Aspect Oriented Programming

관점지향 프로그래밍 입니다. 이게 무슨 소리죠? 이해하기 쉽게 하기 위해서 **Aspect = 로직 **이라고 생각을 해봅시다. 그럼 로직 지향 프로그래밍 입니다.

AOP는 나누는 단위가 Aspect(로직) 단위 입니다. OOP에서 우리가 비슷한 특징을 가진 객체들을 만들고 관리하기 쉽게 하기 위해서 Class를 만들고 그 Class로 객체를 만들어 사용했습니다. AOP에서는 비슷한 특징을 가진 로직들을 따로 나눠 관리하고 사용하는것이 중요한 포인트 입니다. 예를 들어봅니다.

```java
class Boy{
    public void play(){
        System.out.println("문을 열었습니다.");
        System.out.println("컴퓨터를 켰습니다.");
        System.out.println("게임을 실행합니다.");
        System.out.println("컴퓨터를 껐습니다.");
        System.out.println("씻었습니다.");
        System.out.println("침대에 눕습니다.");
    }
}

class Girl{
    public void play(){
        System.out.println("문을 열었습니다.");
        System.out.println("컴퓨터를 켰습니다.");
        System.out.println("인터넷 쇼핑몰을 구경합니다.");
        System.out.println("컴퓨터를 껐습니다.");
        System.out.println("씻었습니다.");
        System.out.println("침대에 눕습니다.");
    }
}
```

위 2개의 클래스는 1가지 행동만 빼고 나머지 행동이 완전히 똑같습니다.  AOP에서는 비슷한 특징을 가진 로직을 모아 또다른 클래스로 사용이 가능하게 됩니다.

```java
@Component
@Aspect
class Aspect{
    @Before("execution(* play())")
    public void beforPlay(){
        System.out.println("문을 열었습니다.");
        System.out.println("컴퓨터를 켰습니다.");
    }
    
    @After("execution(* play())")
    public void afterPlay(){
        System.out.println("컴퓨터를 껐습니다.");
        System.out.println("씻었습니다.");
        System.out.println("침대에 눕습니다.");
    }
}

class Boy{
    public void play(){
        System.out.println("게임을 실행합니다.");
    }
}

class Girl{
    public void play(){
        System.out.println("인터넷 쇼핑몰을 구경합니다.");
    }
}
```

AOP를 적용시켜서 코드를 짜니 Boy, Girl 클래스의 play()메소드가 확실히 많이 줄었습니다. 대신 관련된 파일은 3개로 많아졌지만 후자가 유지보수하기에 더 용이하게 되었습니다. 심지어 SRP(단일책임원칙)을 만족하게 코드를 짜놔 좀더 객체지향적으로 변했습니다.

AOP라는 단어가 생소하고 한국말로 바꿨을 때도 이해가 확실히 안되는부분이 많은데 그저 공통된 로직을 묶어서 순서에 맞게 실행해준다고 생각하시면 됩니다.  AOP는 Traction, 필터, 로거 등등 사실 여러부분에서 중요하게 쓰이고 있는 특징입니다. 실제로 수많은 어노테이션들이 존재하고 있고, 부가적인 기능도 많지만 AOP의 특징을 알고 코드를 보는 것만으로도 아 이건 AOP를 사용해서 코드를 작성하였구나 라고 알 수만 있어도 충분하다고 생각합니다.

# PSA

> Portable Service Abstraction

직역하면 호환성 있는 서비스 추상화?

간단하게 풀어서 말하자면 **잘 만든 인터페이스**입니다. 잘 만든 인터페이스의 특징은 무엇일까요? SOLID랑 4대원칙을 생각해보세요.  현재 객체를 같은 인터페이스를 implements한 다른객체로 손쉽게 대체할 수 있다는 특징을 가지고 있습니다. 인터페이스는 추상화한 객체입니다.

정리하자면 PSA는 손쉽게 대체할수있는 서비스? 말은 이상하지만 이전 보다는 좀더 마음에 와닿지 않나요? 손쉽게 대체할수 있다는 것은 간단하게 의존성만 변경을 하고 이름만 바꾸면 사용할수 있다는 뜻입니다.

우리는 직접 Low Level의 코드를 제어하지 않고 손쉽게 변경할수 있습니다. 실제 DB에서 connection하고 트랜잭션 관리는 Spring에게 맡기고 우리는 로직에만 집중하면 됩니다. (OracleDB든 MySQL이든 연결단계는 설정 몇개만 해주면 Spring이 알아서 연결하게 됩니다.)

PSA 너무 어렵게 생각하면 끝도 없이 어렵습니다. 간단하게 Spring이 인터페이스로 의존성을 주입받아서 Low Level 코드를 알아서 시켜준다. 그래서 우리는 로직에만 집중할 수 있게 도와주는 것이 PSA 입니다!



# 마무리

제가 처음에 스프링은 잘만든 객체지향언어 프레임워크 라고 했던것 기억이 나나요? IoC/DI, AOP, PSA 모두다 OOP, SOLID, 디자인 패턴 개념속에서 움직이고 있습니다.  결국 Spring Triangle은 규칙이라는 것이죠. IoC/DI, AOP, PSA 라는 구조속에서 만들어진 프레임워크입니다. 이 3가지 특징이 Spring의 기본 뼈대가 되어집니다. 개발자들도 자신만의 로직을 만들거나, 이미 만들어진 로직(Spring Security, OAuth, Interceptor) 등을 분석할 때 머릿속에 삼각형의 특징으로 짠 로직들 이라는 생각을 가지고 분석하면 분석하기 쉬워질 겁니다. 어차피 구조는 서로서로 비슷비슷하거든요.



완벽하게 정리된 글은 아니지만 조금이나마 Spring에 이해가 될 수 있었다면 좋겠습니다. 감사합니다.

